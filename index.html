<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAMERA MOVEMENT PROMPT</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #050505; color: #e5e7eb; overflow: hidden; }
        
        /* --- Dynamic Slider Coloring Logic --- */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
            background: #52525b; cursor: pointer; margin-top: -5px;
            border: 1px solid #71717a; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #27272a; border-radius: 2px;
        }

        /* Active Colors */
        input[type=range].active-cyan::-webkit-slider-thumb { background: #fff; border-color: #22d3ee; box-shadow: 0 0 10px #22d3ee, 0 0 20px #22d3ee; }
        input[type=range].active-cyan::-webkit-slider-runnable-track { background: #0e7490; }
        
        input[type=range].active-violet::-webkit-slider-thumb { background: #fff; border-color: #a78bfa; box-shadow: 0 0 10px #a78bfa, 0 0 20px #a78bfa; }
        input[type=range].active-violet::-webkit-slider-runnable-track { background: #5b21b6; }

        input[type=range].active-amber::-webkit-slider-thumb { background: #fff; border-color: #fbbf24; box-shadow: 0 0 10px #fbbf24, 0 0 20px #fbbf24; }
        input[type=range].active-amber::-webkit-slider-runnable-track { background: #92400e; }

        input[type=range].active-emerald::-webkit-slider-thumb { background: #fff; border-color: #34d399; box-shadow: 0 0 10px #34d399, 0 0 20px #34d399; }
        input[type=range].active-emerald::-webkit-slider-runnable-track { background: #065f46; }

        input[type=range].active-rose::-webkit-slider-thumb { background: #fff; border-color: #fb7185; box-shadow: 0 0 10px #fb7185, 0 0 20px #fb7185; }
        input[type=range].active-rose::-webkit-slider-runnable-track { background: #9f1239; }

        input[type=range].active-fuchsia::-webkit-slider-thumb { background: #fff; border-color: #e879f9; box-shadow: 0 0 10px #e879f9, 0 0 20px #e879f9; }
        input[type=range].active-fuchsia::-webkit-slider-runnable-track { background: #86198f; }

        input[type=range].active-blue::-webkit-slider-thumb { background: #fff; border-color: #60a5fa; box-shadow: 0 0 10px #60a5fa, 0 0 20px #60a5fa; }
        input[type=range].active-blue::-webkit-slider-runnable-track { background: #1e40af; }

        /* NEW COLORS for Focal & Pan */
        input[type=range].active-orange::-webkit-slider-thumb { background: #fff; border-color: #f97316; box-shadow: 0 0 10px #f97316, 0 0 20px #f97316; }
        input[type=range].active-orange::-webkit-slider-runnable-track { background: #c2410c; }

        input[type=range].active-indigo::-webkit-slider-thumb { background: #fff; border-color: #6366f1; box-shadow: 0 0 10px #6366f1, 0 0 20px #6366f1; }
        input[type=range].active-indigo::-webkit-slider-runnable-track { background: #4338ca; }


        /* UI Elements */
        .tick-marks { display: flex; justify-content: space-between; height: 4px; margin-top: 6px; padding: 0 6px; }
        .tick { width: 1px; height: 4px; background-color: #444; }
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        
        .pip-container {
            position: absolute; top: 20px; left: 20px; width: 280px; height: 157px; 
            background: #000; border: 1px solid #333; border-radius: 6px; overflow: hidden; z-index: 50;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8); transition: all 0.3s ease;
        }
        .pip-container:hover { border-color: #666; }
        .pip-label {
            position: absolute; top: 8px; left: 10px; font-family: 'JetBrains Mono', monospace; color: #22d3ee;
            font-size: 10px; pointer-events: none; z-index: 51; display: flex; align-items: center; gap: 6px;
            background: rgba(0,0,0,0.8); padding: 3px 8px; border-radius: 4px; border: 1px solid rgba(34, 211, 238, 0.3);
        }
        .pip-label::before {
            content: ''; display: block; width: 6px; height: 6px; background-color: #ef4444; 
            border-radius: 50%; animation: blink 2s infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        .tech-text { color: #fff; }
        .glass-panel { background: rgba(10, 10, 12, 0.95); backdrop-filter: blur(10px); border-right: 1px solid #27272a; }
        .remove-img-btn {
            position: absolute; top: 8px; right: 8px; background: rgba(0, 0, 0, 0.85); border: 1px solid #ef4444;
            color: #ef4444; border-radius: 4px; padding: 4px 8px; font-size: 10px; font-weight: bold; cursor: pointer; z-index: 20;
        }
        .remove-img-btn:hover { background: #ef4444; color: white; }
        .value-changed { color: #facc15 !important; text-shadow: 0 0 8px rgba(250, 204, 21, 0.5) !important; }
        
        /* Interactive Cursor Styles */
        #canvas-container.hover-subject { cursor: ew-resize; } /* For subject rotation */
        #canvas-container.hover-camera { cursor: move; } /* For camera drag */
        #canvas-container.dragging { cursor: grabbing !important; }
    </style>
</head>
<body>

<div id="app" class="flex h-screen w-screen overflow-hidden">
    
    <!-- Sidebar Controls -->
    <div class="w-full md:w-[400px] flex-shrink-0 glass-panel flex flex-col h-full z-10">
        <div class="p-6 border-b border-gray-800/50 flex justify-between items-center relative overflow-hidden">
            <div class="absolute top-0 left-0 w-full h-[1px] bg-gradient-to-r from-transparent via-cyan-900 to-transparent opacity-50"></div>
            <div>
                <h1 class="text-lg font-bold text-white tracking-tight tech-text">CAMERA MOVEMENT <span class="text-cyan-500 font-normal">PROMPT</span></h1>
                <p class="text-[10px] text-gray-500 font-mono tracking-widest mt-1">NANO BANANA PRO OPTIMIZED</p>
            </div>
        </div>

        <div class="flex-1 overflow-y-auto p-6 space-y-8 custom-scrollbar">
            
            <!-- Matrix Mode -->
            <div class="bg-gray-900/40 border border-gray-700/50 rounded-lg p-3 hover:border-gray-600 transition duration-300">
                <label class="flex items-center cursor-pointer space-x-3 select-none">
                    <div class="relative">
                        <input type="checkbox" v-model="matrixMode" class="sr-only peer">
                        <div class="w-9 h-5 bg-gray-800 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-cyan-700 peer-checked:after:bg-cyan-100"></div>
                    </div>
                    <div>
                        <span class="text-sm font-medium text-gray-300">環繞矩陣 (Matrix 12-Cam)</span>
                        <p class="text-[10px] text-gray-500 mt-1">Generates 12 orbit prompts with parallax logic.</p>
                    </div>
                </label>
            </div>

            <!-- Image Upload -->
            <div class="space-y-3">
                <label class="text-[10px] font-bold text-gray-500 uppercase tracking-widest">REFERENCE IMAGE</label>
                <div class="relative group"
                     @dragover.prevent="isDraggingOver = true" @dragleave.prevent="isDraggingOver = false" @drop.prevent="handleDrop">
                    <input type="file" @change="handleImageUpload" accept="image/*" class="hidden" id="fileInput">
                    <label for="fileInput" 
                           class="flex flex-col items-center justify-center w-full h-32 border border-dashed rounded-lg cursor-pointer transition-all overflow-hidden relative"
                           :class="isDraggingOver ? 'border-cyan-400 bg-cyan-900/20' : 'border-gray-700/60 hover:border-cyan-500/50 hover:bg-cyan-900/10 bg-black/40'">
                        <div v-if="!hasImage && !isDraggingOver" class="text-center opacity-60 group-hover:opacity-100 transition duration-300">
                            <span class="text-[10px] text-gray-400 tracking-wide">UPLOAD OR DRAG IMAGE</span>
                        </div>
                        <div v-if="isDraggingOver" class="absolute inset-0 flex items-center justify-center bg-black/60 z-20 backdrop-blur-sm">
                            <span class="text-cyan-400 font-bold tracking-widest animate-pulse border border-cyan-500 px-3 py-1 rounded">DROP TO UPLOAD</span>
                        </div>
                        <img v-if="hasImage" :src="imagePreview" class="w-full h-full object-contain opacity-80 group-hover:opacity-100 transition">
                    </label>
                    <div v-if="hasImage" @click.stop.prevent="clearImage" class="remove-img-btn">CLEAR</div>
                </div>
            </div>

            <!-- Controls -->
            <div class="space-y-8" :class="{ 'opacity-30 pointer-events-none': matrixMode }">
                
                <!-- 1. Horizontal Orbit (Cyan) -->
                <div>
                    <div class="flex justify-between mb-2 items-end">
                        <label class="text-[11px] font-medium text-gray-400">Horizontal Orbit</label>
                        <span class="text-[10px] font-mono transition-colors duration-300" :class="params.horizontal !== 0 ? 'text-cyan-400 font-bold' : 'text-gray-600'">{{ getHorizontalLabel() }}</span>
                    </div>
                    <div class="relative h-6">
                        <input type="range" v-model.number="horizontalIndex" min="0" :max="horizontalSteps.length - 1" step="1"
                               :class="params.horizontal !== 0 ? 'active-cyan' : ''">
                        <div class="tick-marks absolute w-full top-3 pointer-events-none opacity-40">
                            <div v-for="step in horizontalSteps" :key="step" class="tick"></div>
                        </div>
                    </div>
                </div>

                <!-- 2. Vertical Angle (Violet) -->
                <div>
                    <div class="flex justify-between mb-2 items-end">
                        <label class="text-[11px] font-medium text-gray-400">Vertical Angle</label>
                        <span class="text-[10px] font-mono transition-colors duration-300" :class="params.angleIndex !== 3 ? 'text-violet-400 font-bold' : 'text-gray-600'">{{ angleLevels[params.angleIndex].label }}</span>
                    </div>
                    <div class="relative h-6">
                        <input type="range" v-model.number="params.angleIndex" min="0" :max="angleLevels.length - 1" step="1"
                               :class="params.angleIndex !== 3 ? 'active-violet' : ''">
                        <div class="flex justify-between text-[9px] text-gray-500 mt-2 px-1 font-mono w-full">
                            <span>LOW</span><span>LEVEL</span><span>HIGH</span>
                        </div>
                    </div>
                </div>

                <!-- 3. Camera Height (Amber) -->
                <div>
                    <div class="flex justify-between mb-2 items-end">
                        <label class="text-[11px] font-medium text-gray-400">Camera Height</label>
                        <span class="text-[10px] font-mono transition-colors duration-300" :class="params.heightIndex !== 0 ? 'text-amber-400 font-bold' : 'text-gray-600'">{{ heightLevels[params.heightIndex].label }}</span>
                    </div>
                    <div class="relative h-6">
                        <input type="range" v-model.number="params.heightIndex" min="0" :max="heightLevels.length - 1" step="1"
                               :class="params.heightIndex !== 0 ? 'active-amber' : ''">
                        <div class="flex justify-between text-[9px] text-gray-500 mt-2 px-1 font-mono w-full">
                            <span>EYE</span><span>HIP</span><span>GND</span>
                        </div>
                    </div>
                </div>

                <!-- 4. Distance (Emerald) -->
                <div>
                    <div class="flex justify-between mb-2 items-end">
                        <label class="text-[11px] font-medium text-gray-400">Shot Distance</label>
                        <span class="text-[10px] font-mono transition-colors duration-300" :class="params.distanceIndex !== 6 ? 'text-emerald-400 font-bold' : 'text-gray-600'">{{ distanceLevels[params.distanceIndex].label }}</span>
                    </div>
                    <div class="relative h-6">
                        <input type="range" v-model.number="params.distanceIndex" min="0" :max="distanceLevels.length - 1" step="1"
                               :class="params.distanceIndex !== 6 ? 'active-emerald' : ''">
                    </div>
                </div>

                <!-- 5. Camera Motion Group: Pan | Tilt | Roll -->
                 <div class="grid grid-cols-3 gap-3">
                    <!-- Pan (Indigo) -->
                    <div>
                        <div class="flex justify-between mb-2 items-end">
                            <label class="text-[10px] font-medium text-gray-400">Pan</label>
                            <span class="text-[9px] font-mono transition-colors duration-300" :class="params.pan !== 0 ? 'text-indigo-400 font-bold' : 'text-gray-600'">{{ params.pan === 0 ? '0' : (params.pan === -1 ? 'L' : 'R') }}</span>
                        </div>
                        <input type="range" v-model.number="params.pan" min="-1" max="1" step="1"
                               :class="params.pan !== 0 ? 'active-indigo' : ''">
                    </div>
                    <!-- Tilt (Rose) -->
                    <div>
                        <div class="flex justify-between mb-2 items-end">
                            <label class="text-[10px] font-medium text-gray-400">Tilt</label>
                            <span class="text-[9px] font-mono transition-colors duration-300" :class="params.tilt !== 0 ? 'text-rose-400 font-bold' : 'text-gray-600'">{{ params.tilt === 0 ? '0' : (params.tilt > 0 ? 'UP' : 'DN') }}</span>
                        </div>
                        <input type="range" v-model.number="params.tilt" min="-1" max="1" step="1"
                               :class="params.tilt !== 0 ? 'active-rose' : ''">
                    </div>
                     <!-- Roll (Fuchsia) -->
                     <div>
                        <div class="flex justify-between mb-2 items-end">
                            <label class="text-[10px] font-medium text-gray-400">Roll</label>
                            <span class="text-[9px] font-mono transition-colors duration-300" :class="params.roll !== 0 ? 'text-fuchsia-400 font-bold' : 'text-gray-600'">{{ params.roll === 0 ? '0' : 'DT' }}</span>
                        </div>
                        <input type="range" v-model.number="params.roll" min="-45" max="45" step="45"
                               :class="params.roll !== 0 ? 'active-fuchsia' : ''">
                    </div>
                 </div>

                <!-- 6. Focal Length (Orange) -->
                <div>
                    <div class="flex justify-between mb-2 items-end">
                        <label class="text-[11px] font-medium text-gray-400">Focal Length (Zoom)</label>
                        <span class="text-[10px] font-mono transition-colors duration-300" :class="params.focalIndex !== 0 ? 'text-orange-500 font-bold' : 'text-gray-600'">{{ getFocalLabel() }}</span>
                    </div>
                    <div class="relative h-6">
                        <input type="range" v-model.number="params.focalIndex" min="0" :max="focalSteps.length - 1" step="1"
                               :class="params.focalIndex !== 0 ? 'active-orange' : ''">
                         <div class="flex justify-between text-[9px] text-gray-500 mt-2 px-1 font-mono w-full">
                            <span>WIDE</span><span>STD</span><span>TELE</span>
                        </div>
                    </div>
                </div>

                <!-- 7. Subject Rotation (Blue) -->
                <div>
                    <div class="flex justify-between mb-2 items-end">
                        <label class="text-[11px] font-medium text-gray-400">Object Rotation</label>
                        <span class="text-[10px] font-mono transition-colors duration-300" :class="params.subjectRot !== 0 ? 'text-blue-400 font-bold' : 'text-gray-600'">{{ getSubjectRotLabel() }}</span>
                    </div>
                    <input type="range" v-model.number="params.subjectRot" min="-180" max="180" step="45"
                           :class="params.subjectRot !== 0 ? 'active-blue' : ''">
                </div>

            </div>

             <!-- Prompt Output Area -->
             <div class="mt-8 pt-6 border-t border-gray-800/50 pb-12">
                <div class="flex justify-between items-center mb-3">
                    <label class="text-[10px] font-bold text-gray-500 uppercase tracking-widest">Nano Banana Prompt</label>
                    <div class="flex gap-2">
                        <button @click="resetAll" class="text-[10px] bg-red-950/30 text-red-400 border border-red-900/50 px-3 py-1 rounded font-medium transition flex items-center gap-1 group hover:bg-red-900/80 hover:text-red-200 hover:border-red-500/50 hover:shadow-[0_0_15px_rgba(220,38,38,0.2)] active:bg-red-500 active:text-white active:shadow-[0_0_20px_rgba(239,68,68,0.6)]">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 group-hover:-rotate-180 transition-transform duration-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                            RESET
                        </button>
                        <button @click="copyPrompt" class="text-[10px] bg-cyan-900/40 text-cyan-300 hover:bg-cyan-400 hover:text-black border border-cyan-500/50 px-3 py-1 rounded font-medium transition flex items-center gap-2 shadow-[0_0_10px_rgba(34,211,238,0.2)] hover:shadow-[0_0_20px_rgba(34,211,238,0.5)]">
                            <span v-if="!copied">COPY PROMPT</span>
                            <span v-else>COPIED!</span>
                        </button>
                    </div>
                </div>
                <div class="bg-black/80 p-4 rounded border border-gray-700/50 font-mono text-xs text-cyan-100/90 break-words min-h-[100px] leading-relaxed select-all shadow-[inset_0_0_20px_rgba(0,0,0,0.8)] border-l-2 border-l-cyan-500">
                    <span v-if="!generatedPrompt" class="text-gray-600 italic">// Configure rig to generate command sequence...</span>
                    {{ generatedPrompt }}
                </div>
            </div>
        </div>
    </div>

    <!-- 3D Canvas Area -->
    <div class="flex-1 relative bg-[#050505] cursor-default group" id="canvas-container">
        <!-- PIP View -->
        <div class="pip-container">
            <div class="pip-label">REC <span class="text-[8px] text-gray-300 font-normal ml-1">{{ hasImage ? 'LIVE' : 'NO SIGNAL' }}</span></div>
            <div id="pip-canvas" class="w-full h-full"></div>
        </div>
        <!-- Hint -->
        <div class="absolute bottom-6 left-6 text-gray-500 text-[10px] pointer-events-none select-none z-10 font-mono space-y-1">
            <p><span class="text-cyan-600/80">[LMB DRAG CAMERA]</span> ORBIT & ANGLE</p>
            <p><span class="text-blue-500/80">[LMB ON SUBJECT]</span> ROTATE SUBJECT</p>
            <p><span class="text-gray-600/80">[LMB DRAG BG]</span> VIEWPORT ORBIT</p>
            <p><span class="text-emerald-500/80">[SCROLL]</span> VIEWPORT ZOOM</p>
        </div>
    </div>

</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    const { createApp, ref, computed, watch, onMounted } = Vue;

    createApp({
        setup() {
            // State
            const matrixMode = ref(false);
            const hasImage = ref(false);
            const imagePreview = ref(null);
            const copied = ref(false);
            const isDraggingOver = ref(false);

            // --- DATA DEFINITIONS ---
            const horizontalSteps = [-180, -135, -90, -60, -45, -30, 0, 30, 45, 60, 90, 135, 180];
            const focalSteps = [0, 6, 8, 11, 12, 13, 14, 16, 20, 24, 28, 35, 50, 85, 100, 135, 200, 300, 400, 500, 600, 800, 1200, 2000];

            const distanceLevels = [
                { label: "Probe Lens", prompt: "Probe Lens", radius: 0.5, parallax: "[Parallax]: Background extremely blurred with intense bokeh due to macro depth of field." },
                { label: "Macro", prompt: "Macro Shot", radius: 0.8, parallax: "[Parallax]: Background becomes an abstract wash of color; depth of field is paper-thin." },
                { label: "Detail", prompt: "Detail Shot", radius: 1.2, parallax: "[Parallax]: Background details are softened to emphasize foreground texture." },
                { label: "ECU", prompt: "Extreme Close-Up (ECU)", radius: 1.6, parallax: "[Parallax]: Background compression isolates the facial features completely." },
                { label: "Close-Up", prompt: "Close-Up (CU)", radius: 2.2, parallax: "[Parallax]: Background blur increases to separate subject from environment." },
                { label: "MCU", prompt: "Medium Close-Up (MCU)", radius: 3.0, parallax: "[Parallax]: Slight background compression, maintaining focus on expression." },
                { label: "Medium", prompt: "Medium Shot (MS)", radius: 4.0, parallax: "" }, // Default [6]
                { label: "Cowboy", prompt: "Cowboy Shot", radius: 5.5, parallax: "[Parallax]: Background reveals more waist-level environment context." },
                { label: "MLS", prompt: "Medium Long Shot (MLS)", radius: 6.5, parallax: "[Parallax]: Background elements scale down relative to the subject." },
                { label: "Full", prompt: "Full Shot", radius: 7.5, parallax: "[Parallax]: Full environmental context visible; ground plane interaction is clear." },
                { label: "Wide", prompt: "Wide Shot (WS)", radius: 9.0, parallax: "[Parallax]: Significant background expansion; subject is integrated into the scene." },
                { label: "EWS", prompt: "Extreme Wide Shot (EWS)", radius: 12.0, parallax: "[Parallax]: Background dominates the frame; massive environmental scale." }
            ];

            const angleLevels = [
                { label: "Nadir / Undershot", prompt: "Nadir View", phi: 170, parallax: "[Parallax]: Background replaced by ceiling/sky elements looking straight up." },
                { label: "Worm's Eye", prompt: "Worm's Eye View", phi: 130, parallax: "[Parallax]: Background shifts significantly upwards; towering perspective." },
                { label: "Low Angle", prompt: "Low Angle Shot", phi: 110, parallax: "[Parallax]: Horizon line drops; ceiling/sky becomes more prominent in background." },
                { label: "Level (0°)", prompt: "", phi: 90, parallax: "" }, // Default [3]
                { label: "High Angle", prompt: "High Angle Shot", phi: 60, parallax: "[Parallax]: Horizon line rises; ground plane fills more of the background." },
                { label: "Bird's Eye", prompt: "Bird's Eye View", phi: 40, parallax: "[Parallax]: Background shifts to reveal floor/ground texture clearly." },
                { label: "God's Eye", prompt: "God's Eye View", phi: 10, parallax: "[Parallax]: Background becomes the ground map directly below." }
            ];

            const heightLevels = [
                { label: "Eye-Level", prompt: "", yOffset: 1.6 }, // Default [0]
                { label: "Shoulder Level", prompt: "Shoulder Level Shot", yOffset: 1.4 },
                { label: "Hip Level", prompt: "Hip Level Shot", yOffset: 0.9 },
                { label: "Knee Level", prompt: "Knee Level Shot", yOffset: 0.5 },
                { label: "Ground Level", prompt: "Ground Level Shot", yOffset: 0.1 }
            ];

            const params = ref({
                horizontal: 0,
                angleIndex: 3,
                heightIndex: 0,
                distanceIndex: 6,
                focalIndex: 0, // Default Off
                pan: 0, // -1 Left, 0 Off, 1 Right
                tilt: 0,
                roll: 0,
                subjectRot: 0
            });

            // Computed for Horizontal Slider
            const horizontalIndex = computed({
                get: () => horizontalSteps.indexOf(params.value.horizontal),
                set: (idx) => { params.value.horizontal = horizontalSteps[idx]; }
            });

            const resetAll = () => {
                params.value = {
                    horizontal: 0,
                    angleIndex: 3,
                    heightIndex: 0,
                    distanceIndex: 6,
                    focalIndex: 0,
                    pan: 0,
                    tilt: 0,
                    roll: 0,
                    subjectRot: 0
                };
            };

            // --- Prompt Logic ---
            const getHorizontalPrompt = () => {
                const h = params.value.horizontal;
                if (h === 0) return "[Camera]: 0° Frontal View. [Orientation]: Subject facing directly at camera. [Logic]: Static background, perfect symmetry.";
                
                const absH = Math.abs(h);
                // Swapped Left/Right logic to correct for AI interpretation
                // If Slider is Positive (Right), prompts are "Right"
                if (h > 0) {
                    if (absH <= 30) return `[Camera]: 30° Right, slight angle. [Orientation]: Subject facing slightly screen-left. [Logic]: Parallax background movement from right to left.`;
                    if (absH <= 45) return `[Camera]: 45° Right, standard 3/4 view. [Orientation]: Subject facing screen-left. [Logic]: Background shifts left relative to subject.`;
                    if (absH <= 60) return `[Camera]: 60° Right, deep angle. [Orientation]: Subject facing sharply screen-left. [Logic]: Significant background shift to the left.`;
                    if (absH <= 90) return `[Camera]: 90° Right side, full profile view. [Orientation]: Subject facing screen-left. [Logic]: Parallax background movement from right to left.`;
                    if (absH <= 135) return `[Camera]: 135° Right-Rear, over-the-shoulder. [Orientation]: Subject facing away towards screen-left. [Logic]: Background transitions to rear view.`;
                    return `[Camera]: 180° Direct Rear. [Orientation]: Subject facing away from camera. [Logic]: Full rear landscape view.`;
                } 
                if (h < 0) {
                    if (absH <= 30) return `[Camera]: 30° Left, slight angle. [Orientation]: Subject facing slightly screen-right. [Logic]: Parallax background movement from left to right.`;
                    if (absH <= 45) return `[Camera]: 45° Left, standard 3/4 view. [Orientation]: Subject facing screen-right. [Logic]: Background shifts right relative to subject.`;
                    if (absH <= 60) return `[Camera]: 60° Left, deep angle. [Orientation]: Subject facing sharply screen-right. [Logic]: Significant background shift to the right.`;
                    if (absH <= 90) return `[Camera]: 90° Left side, full profile view. [Orientation]: Subject facing screen-right. [Logic]: Parallax background movement from left to right.`;
                    if (absH <= 135) return `[Camera]: 135° Left-Rear, over-the-shoulder. [Orientation]: Subject facing away towards screen-right. [Logic]: Background transitions to rear view.`;
                    return `[Camera]: 180° Direct Rear. [Orientation]: Subject facing away from camera. [Logic]: Full rear landscape view.`;
                }
                return "";
            };

            const getHorizontalLabel = () => {
                const h = params.value.horizontal;
                if (h === 0) return "FRONT";
                return `${Math.abs(h)}° ${h > 0 ? 'R' : 'L'}`;
            };

            const getAnglePrompt = () => {
                const idx = params.value.angleIndex;
                if (idx === 3) return "";
                const data = angleLevels[idx];
                return `Adjust camera angle to ${data.prompt}. ${data.parallax}`;
            };

            const getHeightPrompt = () => {
                const idx = params.value.heightIndex;
                if (idx === 0) return ""; 
                return `Position camera at ${heightLevels[idx].prompt}. [Parallax]: Perspective shifts vertically to match ${heightLevels[idx].label} height relative to subject.`;
            };

            const getDistancePrompt = () => {
                const idx = params.value.distanceIndex;
                if (idx === 6) return ""; 
                const data = distanceLevels[idx];
                return `Change shot size to ${data.prompt}. ${data.parallax}`;
            };

            const getFocalLabel = () => {
                const fl = focalSteps[params.value.focalIndex];
                if(fl === 0) return "DEFAULT";
                return `${fl}mm`;
            };

            const getFocalPrompt = () => {
                const fl = focalSteps[params.value.focalIndex];
                if(fl === 0) return "";
                if(fl <= 16) return `Shot on ${fl}mm Ultra-Wide Fisheye lens. [Visual]: Extreme barrel distortion, exaggerated perspective depth.`;
                if(fl <= 35) return `Shot on ${fl}mm Wide Angle lens. [Visual]: Expanded field of view, dynamic perspective.`;
                if(fl <= 50) return `Shot on ${fl}mm Standard lens. [Visual]: Natural human eye perspective, minimal distortion.`;
                if(fl <= 100) return `Shot on ${fl}mm Portrait Telephoto lens. [Visual]: Flattering compression, subject isolation, soft bokeh.`;
                if(fl <= 2000) return `Shot on ${fl}mm Super Telephoto lens. [Visual]: Extreme background compression, flat perspective, subject pulled close to background.`;
                return "";
            };

            const getPanPrompt = () => {
                if(params.value.pan === -1) return "Camera Pans Left. [Motion]: View sweeps left, revealing scene to the left.";
                if(params.value.pan === 1) return "Camera Pans Right. [Motion]: View sweeps right, revealing scene to the right.";
                return "";
            };

            const getRollPrompt = () => params.value.roll !== 0 ? "Apply a Dutch Angle tilt. [Parallax]: Horizon line tilts diagonally matching the roll angle." : "";
            const getTiltPrompt = () => params.value.tilt !== 0 ? (params.value.tilt > 0 ? "Tilt Up. [Parallax]: Vertical perspective converges upwards." : "Tilt Down. [Parallax]: Vertical perspective converges downwards.") : "";
            
            const getSubjectRotPrompt = () => {
                const r = params.value.subjectRot;
                if (r === 0) return "";
                if (Math.abs(r) === 90) return "Rotate the object itself to reveal its Side Profile. [Constraint]: Camera fixed. Background must remain static and unchanged.";
                if (Math.abs(r) === 180) return "Rotate the object itself to reveal its Back View. [Constraint]: Camera fixed. Background must remain static and unchanged.";
                return `Rotate the object itself ${r} degrees. [Constraint]: Camera fixed. Background must remain static and unchanged.`;
            };
            const getSubjectRotLabel = () => params.value.subjectRot === 0 ? "FRONT" : `${params.value.subjectRot}°`;

            const generatedPrompt = computed(() => {
                if (matrixMode.value) return "Matrix Mode: [Generating 12-Angle Sequence...]";
                let commands = [];
                const p_hor = getHorizontalPrompt();
                const p_ang = getAnglePrompt();
                const p_hgt = getHeightPrompt();
                const p_foc = getFocalPrompt();
                const p_dist = getDistancePrompt();
                const p_pan = getPanPrompt();
                const p_roll = getRollPrompt();
                const p_tilt = getTiltPrompt();
                const p_sub = getSubjectRotPrompt();

                if (p_hor) commands.push(p_hor);
                if (p_ang) commands.push(p_ang);
                if (p_hgt) commands.push(p_hgt);
                if (p_pan) commands.push(p_pan); // Pan should be prioritized as motion
                if (p_roll) commands.push(p_roll);
                if (p_tilt) commands.push(p_tilt);
                if (p_foc) commands.push(p_foc);
                if (p_dist) commands.push(p_dist);
                if (p_sub) commands.push(p_sub);

                if (commands.length === 0) return "";

                let anchor = "Maintaining strict consistency with all subject details, lighting, and background elements of the reference image.";
                if (p_sub) anchor = "The camera remains fixed. Background and lighting must stay static and identical to reference.";

                return commands.join(", ") + ". " + anchor;
            });

            // --- Three.js Logic ---
            let scene, camera, renderer, pipRenderer, controls, pipCamera, composer, subjectMesh, cameraRigGroup, cameraModel, matrixGroup, masterMiniCamera;
            let currentSubjectHeight = 2.0;
            let isDragging = false;
            let dragMode = null; // 'orbit', 'subject', 'camera'
            let raycaster = new THREE.Raycaster();
            let mouse = new THREE.Vector2();
            let dragPlane;
            
            // Accumulators for snapping logic
            let dragAccumulatorX = 0;
            let dragAccumulatorY = 0;
            const SNAP_THRESHOLD_X = 30; 
            const SNAP_THRESHOLD_Y = 30; 
            const SNAP_THRESHOLD_ROT = 40; 

            // --- Setup Helpers ---
            const handleImageUpload = (e) => { const file = e.target.files[0]; if(file) processFile(file); };
            const handleDrop = (e) => { isDraggingOver.value = false; const file = e.dataTransfer.files[0]; if(file && file.type.startsWith('image/')) processFile(file); };
            const processFile = (file) => { const reader = new FileReader(); reader.onload = (ev) => { imagePreview.value = ev.target.result; hasImage.value = true; updateTexture(ev.target.result); }; reader.readAsDataURL(file); };
            const clearImage = () => { hasImage.value = false; imagePreview.value = null; updateTexture(null); document.getElementById('fileInput').value = ""; };
            const copyPrompt = () => { if(!generatedPrompt.value) return; const ta = document.createElement('textarea'); ta.value = generatedPrompt.value; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); copied.value = true; setTimeout(()=>copied.value=false, 2000); };

            const addGlowOutline = (mesh, color = 0x00ffff) => {
                const edges = new THREE.EdgesGeometry(mesh.geometry);
                const lineMat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending });
                const lines = new THREE.LineSegments(edges, lineMat);
                mesh.add(lines);
            };
            const createMasterMiniCamera = () => { const grp = new THREE.Group(); const body = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.15), new THREE.MeshStandardMaterial({color:0x111111})); addGlowOutline(body, 0x00ffff); grp.add(body); const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.1, 16), new THREE.MeshStandardMaterial({color:0x000000})); lens.rotateX(Math.PI/2); lens.position.z = 0.11; addGlowOutline(lens, 0x00ffff); grp.add(lens); return grp; };
            const createCameraModel = () => { const grp = new THREE.Group(); const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.5), new THREE.MeshStandardMaterial({color:0x1a1a1a})); addGlowOutline(body, 0x00ffff); grp.add(body); const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.3, 32), new THREE.MeshStandardMaterial({color:0x050505})); lens.rotateX(Math.PI/2); lens.position.z = 0.35; addGlowOutline(lens, 0x00ffff); grp.add(lens); const hit = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({visible:false})); hit.userData = {isCamera:true}; grp.add(hit); cameraRigGroup.add(grp); cameraModel = grp; };

            const initThreeJS = () => {
                const container = document.getElementById('canvas-container');
                const pipDiv = document.getElementById('pip-canvas');
                scene = new THREE.Scene(); scene.background = new THREE.Color(0x050505);
                scene.add(new THREE.GridHelper(20, 20, 0x333333, 0x1a1a1a));
                
                camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000);
                camera.position.set(6, 4, 8);
                
                pipCamera = new THREE.PerspectiveCamera(50, pipDiv.clientWidth/pipDiv.clientHeight, 0.1, 100);
                
                renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.toneMapping = THREE.ReinhardToneMapping;
                container.appendChild(renderer.domElement);
                
                pipRenderer = new THREE.WebGLRenderer({antialias:true});
                pipRenderer.setSize(pipDiv.clientWidth, pipDiv.clientHeight);
                pipDiv.appendChild(pipRenderer.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.3));
                const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,10,5); scene.add(dir);
                
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.6; bloomPass.strength = 1.0; bloomPass.radius = 0.8;
                composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass); composer.addPass(new OutputPass());

                subjectMesh = new THREE.Mesh(new THREE.PlaneGeometry(1,1), new THREE.MeshStandardMaterial({color:0x888888, side:THREE.DoubleSide, transparent:true}));
                subjectMesh.scale.set(1.5, 2, 1); subjectMesh.position.y = 1; scene.add(subjectMesh);
                subjectMesh.userData = { isSubject: true };

                cameraRigGroup = new THREE.Group(); scene.add(cameraRigGroup);
                createCameraModel();
                masterMiniCamera = createMasterMiniCamera();
                matrixGroup = new THREE.Group(); scene.add(matrixGroup);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                
                dragPlane = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshBasicMaterial({visible:false})); 
                dragPlane.rotation.x = -Math.PI/2; 
                scene.add(dragPlane);

                const cvs = renderer.domElement;
                cvs.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
                window.addEventListener('resize', onWindowResize);
                animate();
            };

            const updateTexture = (url) => {
                if(!subjectMesh) return;
                if(url) {
                    new THREE.TextureLoader().load(url, (tex) => {
                        tex.colorSpace = THREE.SRGBColorSpace; subjectMesh.material.map = tex; subjectMesh.material.color.setHex(0xffffff); subjectMesh.material.needsUpdate=true;
                        const asp = tex.image.width / tex.image.height;
                        if(asp>=1) subjectMesh.scale.set(2, 2/asp, 1); else subjectMesh.scale.set(2*asp, 2, 1);
                        currentSubjectHeight = subjectMesh.scale.y; subjectMesh.position.y = currentSubjectHeight/2;
                    });
                } else {
                    subjectMesh.material.map = null; subjectMesh.material.color.setHex(0x555555); subjectMesh.scale.set(1.5,2,1); subjectMesh.position.y=1; currentSubjectHeight=2;
                }
            };

            const onMouseDown = (e) => {
                if(e.button !== 0) return;
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left)/rect.width)*2-1; 
                mouse.y = -((e.clientY - rect.top)/rect.height)*2+1;
                raycaster.setFromCamera(mouse, camera);
                
                const hitCam = raycaster.intersectObjects(cameraRigGroup.children, true).find(o=>o.object.userData.isCamera);
                const hitSub = raycaster.intersectObjects([subjectMesh], false).length > 0;
                
                if (hitCam) {
                    dragMode = 'camera'; isDragging = true; controls.enabled = false;
                    document.getElementById('canvas-container').classList.add('dragging');
                } else if (hitSub) {
                    dragMode = 'subject'; isDragging = true; controls.enabled = false;
                    document.getElementById('canvas-container').classList.add('dragging');
                } else {
                    dragMode = null; isDragging = false; controls.enabled = true;
                }
                dragAccumulatorX = 0; dragAccumulatorY = 0;
            };

            const onMouseMove = (e) => {
                const container = document.getElementById('canvas-container');
                if (!isDragging) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((e.clientX - rect.left)/rect.width)*2-1; 
                    mouse.y = -((e.clientY - rect.top)/rect.height)*2+1;
                    raycaster.setFromCamera(mouse, camera);
                    const hitCam = raycaster.intersectObjects(cameraRigGroup.children, true).find(o=>o.object.userData.isCamera);
                    const hitSub = raycaster.intersectObjects([subjectMesh], false).length > 0;
                    if (hitCam) { container.classList.add('hover-camera'); container.classList.remove('hover-subject'); } 
                    else if (hitSub) { container.classList.add('hover-subject'); container.classList.remove('hover-camera'); } 
                    else { container.classList.remove('hover-camera'); container.classList.remove('hover-subject'); }
                    return;
                }
                if (isDragging) {
                    dragAccumulatorX += e.movementX; dragAccumulatorY += e.movementY;
                    if (dragMode === 'camera') {
                        if (Math.abs(dragAccumulatorX) > SNAP_THRESHOLD_X) {
                            const steps = Math.floor(Math.abs(dragAccumulatorX) / SNAP_THRESHOLD_X) * Math.sign(dragAccumulatorX);
                            let newIdx = horizontalIndex.value + steps;
                            if (newIdx >= horizontalSteps.length) newIdx = 0; if (newIdx < 0) newIdx = horizontalSteps.length - 1;
                            horizontalIndex.value = newIdx; dragAccumulatorX = 0;
                        }
                        if (Math.abs(dragAccumulatorY) > SNAP_THRESHOLD_Y) {
                            const steps = Math.floor(Math.abs(dragAccumulatorY) / SNAP_THRESHOLD_Y) * Math.sign(dragAccumulatorY);
                            let newVIdx = params.value.angleIndex - steps;
                            if (newVIdx < 0) newVIdx = 0; if (newVIdx >= angleLevels.length) newVIdx = angleLevels.length - 1;
                            params.value.angleIndex = newVIdx; dragAccumulatorY = 0;
                        }
                    } else if (dragMode === 'subject') {
                        if (Math.abs(dragAccumulatorX) > SNAP_THRESHOLD_ROT) {
                            const steps = Math.floor(Math.abs(dragAccumulatorX) / SNAP_THRESHOLD_ROT) * Math.sign(dragAccumulatorX);
                            let newRot = params.value.subjectRot + (steps * 45);
                            if (newRot > 180) newRot = 180; if (newRot < -180) newRot = -180;
                            params.value.subjectRot = newRot; dragAccumulatorX = 0;
                        }
                    }
                }
            };

            const onMouseUp = () => { isDragging = false; dragMode = null; controls.enabled = true; document.getElementById('canvas-container').classList.remove('dragging'); };

            const updateRig = () => {
                if(!subjectMesh || !cameraRigGroup) return;
                subjectMesh.rotation.y = THREE.MathUtils.degToRad(params.value.subjectRot);
                const centerY = currentSubjectHeight / 2;

                const r = distanceLevels[params.value.distanceIndex].radius;
                const phi = THREE.MathUtils.degToRad(angleLevels[params.value.angleIndex].phi);
                const theta = THREE.MathUtils.degToRad(params.value.horizontal);
                const hOffset = heightLevels[params.value.heightIndex].yOffset;

                const x = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.sin(phi) * Math.cos(theta);
                const yAngle = r * Math.cos(phi) + centerY;
                const finalY = yAngle + (hOffset - 1.6); 

                cameraRigGroup.position.set(x, finalY, z);
                cameraRigGroup.lookAt(0, centerY, 0);
                
                // Pan Logic
                if (params.value.pan !== 0) {
                    cameraRigGroup.rotateY(THREE.MathUtils.degToRad(params.value.pan * -15)); 
                }

                cameraRigGroup.rotateZ(-THREE.MathUtils.degToRad(params.value.roll));
                cameraRigGroup.rotateX(THREE.MathUtils.degToRad(-params.value.tilt * 20));

                pipCamera.position.copy(cameraRigGroup.position);
                pipCamera.quaternion.copy(cameraRigGroup.quaternion);
                pipCamera.rotateY(Math.PI);
                
                // Focal Length Logic
                const fl = focalSteps[params.value.focalIndex];
                if (fl > 0) {
                    const sensorHeight = 24; 
                    const fov = 2 * Math.atan(sensorHeight / (2 * fl)) * (180 / Math.PI);
                    pipCamera.fov = fov;
                } else {
                    pipCamera.fov = 50; 
                }
                pipCamera.updateProjectionMatrix();

                updateMatrixVisuals(0, centerY, 0, r, phi, hOffset);
            };

            const updateMatrixVisuals = (cx, cy, cz, r, phi, hOff) => {
                while(matrixGroup.children.length>0) matrixGroup.remove(matrixGroup.children[0]);
                if(!matrixMode.value) { cameraModel.visible=true; return; }
                cameraModel.visible=false;
                if(!masterMiniCamera) return;
                for(let i=0; i<12; i++) {
                    const ang = THREE.MathUtils.degToRad(i*30);
                    const c = masterMiniCamera.clone();
                    const x = r * Math.sin(phi) * Math.sin(ang);
                    const z = r * Math.sin(phi) * Math.cos(ang);
                    const y = r * Math.cos(phi) + cy + (hOff - 1.6);
                    c.position.set(x,y,z);
                    c.lookAt(cx,cy,cz);
                    matrixGroup.add(c);
                }
            };

            const animate = () => {
                requestAnimationFrame(animate);
                controls.update(); 
                updateRig();
                if(composer) composer.render(); else renderer.render(scene, camera);
                
                const v1 = cameraRigGroup.visible; const v2 = matrixGroup.visible;
                cameraRigGroup.visible=false; matrixGroup.visible=false;
                pipRenderer.render(scene, pipCamera);
                cameraRigGroup.visible=v1; matrixGroup.visible=v2;
            };

            const onWindowResize = () => {
                const c = document.getElementById('canvas-container');
                camera.aspect = c.clientWidth/c.clientHeight; camera.updateProjectionMatrix();
                renderer.setSize(c.clientWidth, c.clientHeight); composer.setSize(c.clientWidth, c.clientHeight);
            };

            onMounted(()=>initThreeJS());

            return { 
                matrixMode, params, isDraggingOver,
                horizontalSteps, horizontalIndex, focalSteps,
                angleLevels, heightLevels, distanceLevels, 
                generatedPrompt, hasImage, imagePreview, handleImageUpload, handleDrop, clearImage, copyPrompt, copied, resetAll,
                getHorizontalLabel, getSubjectRotLabel, getFocalLabel
            };
        }
    }).mount('#app');
</script>
</body>
</html>
